class EventBus{constructor(){this.events={}}on(t,e,s,...n){void 0===this.events[t]&&(this.events[t]=[]),this.events[t].push({scope:s,callback:e,args:n})}off(t,e,s){if(void 0===this.events[t])return;let n=[];for(const o of this.events[t]){o.scope==s&&o.callback==e||n.push(o)}this.events[t]=n}has(t,e,s){if(void 0===this.events[t])return!1;let n=this.events[t].length;if(void 0===e&&void 0===s)return n>0;for(const n of this.events[t]){const t=!s||n.scope==s,o=n.callback==e;if(t&&o)return!0}return!1}emit(t,e,...s){if(void 0===this.events[t])return;s=[{type:t,target:e}].concat(s);const n=this.events[t].slice();for(const t of n)if(t&&t.callback){const e=s.concat(t.args);t.callback.apply(t.scope,e)}}debug(){let t="";for(const e in this.events)for(const s of this.events[e]){let n="Anonymous";s.scope&&s.scope.constructor.name&&(n=s.scope.constructor.name),t+=`${n} listening for "${e}"\n`}return t}}var eventbus=new EventBus;export default eventbus;
//# sourceMappingURL=eventbus.esm.min.js.map
