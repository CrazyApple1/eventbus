{"version":3,"file":"eventbus.esm.min.js","sources":["../src/eventbus.js"],"sourcesContent":["class EventBus {\n\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * Adds listener to EventBus\n     * @param {string} type The name of the event to listen for\n     * @param {function} callback Callback to call when event was triggered\n     * @param {object} scope The scope in which the callback shall be executed\n     * @param  {...any} args Any number of args to be passed to the callback\n     */\n    on(type, callback, scope, ...args) {\n        if (typeof this.events[type] === \"undefined\") { // Check if there is already event of this type registered\n            this.events[type] = []; // If not, create array for it\n        }\n        this.events[type].push({scope, callback, args}); // Finally push new event to events array\n    }\n\n    /**\n     * Removes listener from EventBus\n     * @param {string} type The name of the event to remove\n     * @param {function} callback Callback of the event to remove\n     * @param {object} scope The scope of the to be removed event\n     */\n    off(type, callback, scope) {\n        if (typeof this.events[type] === \"undefined\") { // Check if event of this type exists\n            return; // If not just return\n        }\n\n        let newArray = []; // Array that will contain all events except the one removed\n        for (const event of this.events[type]) { // Iterate all events of the specified type\n            // Check if the event of the current iteration and the passed one are equal\n            const isSame = event.scope == scope && event.callback == callback;\n            if (!isSame) { // If they are not the same...\n                newArray.push(event); // ...push the current event to the newArray\n            }\n        }\n\n        this.events[type] = newArray; // Reset the events array with all events except the removed one\n    }\n\n    /**\n     * Checks if the passed event is registered in the EventBus\n     * @param {string} type Type of the to be checked event\n     * @param {callback} callback Callback of the to be checked event\n     * @param {object} scope Scope of the to be checked event\n     */\n    has(type, callback, scope) {\n        if (typeof this.events[type] === \"undefined\") { // Check if the passed type even exists\n            return false; // If not, quit method\n        }\n\n        // If callback and scope are undefined then every registered event is match, thus any event of the type matches\n        let numOfCallbacks = this.events[type].length;\n        if (callback === undefined && scope === undefined) { // If scope and callback are not defined\n            return numOfCallbacks > 0; // If there are any callbacks we can be sure it matches the passed one\n        }\n\n        for (const event of this.events[type]) { // Iterate all events of the passed type\n            const scopeIsSame = scope ? event.scope == scope : true; // Check if scope is equal to the one passed\n            const callbackIsSame = event.callback == callback; // Check if callback is equal to the one passed\n            if (scopeIsSame && callbackIsSame) { // Check if current event and passed event are equal\n                return true; // If so, break loop and return true\n            }\n        }\n\n        return false; // If there aren't any events it cannot match\n    }\n\n    /**\n     * Emits an event on the EventBus\n     * @param {string} type Type of event to emit\n     * @param {object} target The caller \n     * @param {...any} args Any number of args to be passed to the callback\n     */\n    emit(type, target, ...args) {\n        if (typeof this.events[type] === \"undefined\") { // Check if any event of the passed type exists\n            return; // If not, quit method\n        }\n\n        let bag = {\n            type: type,\n            target: target\n        };\n        \n        args = [bag].concat(args); // Merge arrays\n        const events = this.events[type].slice(); // Little hack to clone array\n\n        for (const event of events) { // Iterate all events\n            if (event && event.callback) { // Check if callback of event is set \n                const concatArgs = args.concat(event.args); // Add args that were passed\n                event.callback.apply(event.scope, concatArgs); // Call callback\n            }\n        }\n    }\n\n    debug() {\n        let str = \"\";\n        for (const type in this.events) {\n            for (const event of this.events[type]) {\n                let className = \"Anonymous\";\n                if (event.scope) {\n                    if (event.scope.constructor.name) {\n                        className = event.scope.constructor.name;\n                    }\n                }\n                str += `${className} listening for \"${type}\"\\n`;\n            }\n        }\n        return str;\n    }\n\n};\n\nexport default new EventBus();\n"],"names":["EventBus","[object Object]","this","events","type","callback","scope","args","push","newArray","event","numOfCallbacks","length","undefined","scopeIsSame","callbackIsSame","target","concat","slice","concatArgs","apply","str","className","constructor","name"],"mappings":"AAAA,MAAMA,SAEFC,cACIC,KAAKC,OAAS,GAUlBF,GAAGG,EAAMC,EAAUC,KAAUC,QACQ,IAAtBL,KAAKC,OAAOC,KACnBF,KAAKC,OAAOC,GAAQ,IAExBF,KAAKC,OAAOC,GAAMI,KAAK,CAACF,MAAAA,EAAOD,SAAAA,EAAUE,KAAAA,IAS7CN,IAAIG,EAAMC,EAAUC,GAChB,QAAiC,IAAtBJ,KAAKC,OAAOC,GACnB,OAGJ,IAAIK,EAAW,GACf,IAAK,MAAMC,KAASR,KAAKC,OAAOC,GAAO,CAEpBM,EAAMJ,OAASA,GAASI,EAAML,UAAYA,GAErDI,EAASD,KAAKE,GAItBR,KAAKC,OAAOC,GAAQK,EASxBR,IAAIG,EAAMC,EAAUC,GAChB,QAAiC,IAAtBJ,KAAKC,OAAOC,GACnB,OAAO,EAIX,IAAIO,EAAiBT,KAAKC,OAAOC,GAAMQ,OACvC,QAAiBC,IAAbR,QAAoCQ,IAAVP,EAC1B,OAAOK,EAAiB,EAG5B,IAAK,MAAMD,KAASR,KAAKC,OAAOC,GAAO,CACnC,MAAMU,GAAcR,GAAQI,EAAMJ,OAASA,EACrCS,EAAiBL,EAAML,UAAYA,EACzC,GAAIS,GAAeC,EACf,OAAO,EAIf,OAAO,EASXd,KAAKG,EAAMY,KAAWT,GAClB,QAAiC,IAAtBL,KAAKC,OAAOC,GACnB,OAQJG,EAAO,CALG,CACNH,KAAMA,EACNY,OAAQA,IAGCC,OAAOV,GACpB,MAAMJ,EAASD,KAAKC,OAAOC,GAAMc,QAEjC,IAAK,MAAMR,KAASP,EAChB,GAAIO,GAASA,EAAML,SAAU,CACzB,MAAMc,EAAaZ,EAAKU,OAAOP,EAAMH,MACrCG,EAAML,SAASe,MAAMV,EAAMJ,MAAOa,IAK9ClB,QACI,IAAIoB,EAAM,GACV,IAAK,MAAMjB,KAAQF,KAAKC,OACpB,IAAK,MAAMO,KAASR,KAAKC,OAAOC,GAAO,CACnC,IAAIkB,EAAY,YACZZ,EAAMJ,OACFI,EAAMJ,MAAMiB,YAAYC,OACxBF,EAAYZ,EAAMJ,MAAMiB,YAAYC,MAG5CH,MAAUC,oBAA4BlB,OAG9C,OAAOiB,GAKf,aAAe,IAAIrB"}