{"version":3,"file":"eventbus.esm.min.js","sources":["../src/eventbus.js"],"sourcesContent":["export class EventBus {\n\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * Adds listener to EventBus\n     * @param {string} type The name of the event to listen for\n     * @param {function} callback Callback to call when event was triggered\n     * @param {object} scope The scope in which the callback shall be executed\n     * @param  {...any} args Any number of args to be passed to the callback\n     */\n    on(type, callback, scope, ...args) {\n        if (typeof this.events[type] === \"undefined\") { // Check if there is already event of this type registered\n            this.events[type] = []; // If not, create array for it\n        }\n        this.events[type].push({scope, callback, args}); // Finally push new event to events array\n    }\n\n    /**\n     * Removes listener from EventBus\n     * @param {string} type The name of the event to remove\n     * @param {function} callback Callback of the event to remove\n     * @param {object} scope The scope of the to be removed event\n     */\n    off(type, callback, scope) {\n        if (typeof this.events[type] === \"undefined\") { // Check if event of this type exists\n            return; // If not just return\n        }\n\n        // keep all elements that aren't equal to the passed event\n        const filterFn = event => event.scope !== scope || event.callback !== callback;\n        this.events[type] = this.events[type].filter(filterFn);\n    }\n\n    /**\n     * Checks if the passed event is registered in the EventBus\n     * @param {string} type Type of the to be checked event\n     * @param {callback} callback Callback of the to be checked event\n     * @param {object} scope Scope of the to be checked event\n     */\n    has(type, callback, scope) {\n        if (typeof this.events[type] === \"undefined\") { // Check if the passed type even exists\n            return false; // If not, quit method\n        }\n\n        // If callback and scope are undefined then every registered event is match, thus any event of the type matches\n        let numOfCallbacks = this.events[type].length;\n        if (callback === undefined && scope === undefined) { // If scope and callback are not defined\n            return numOfCallbacks > 0; // If there are any callbacks we can be sure it matches the passed one\n        }\n\n        const conditionFn = event => {\n            const scopeIsSame = scope ? event.scope === scope : true; // Check if scope is equal to the one passed\n            const callbackIsSame = event.callback === callback; // Check if callback is equal to the one passed\n            if (scopeIsSame && callbackIsSame) { // Check if current event and passed event are equal\n                return true; // If so, break loop and return true\n            }\n        };\n        return this.events[type].some(conditionFn);\n    }\n\n    /**\n     * Emits an event on the EventBus\n     * @param {string} type Type of event to emit\n     * @param {object} target The caller \n     * @param {...any} args Any number of args to be passed to the callback\n     */\n    emit(type, target, ...args) {\n        if (typeof this.events[type] === \"undefined\") { // Check if any event of the passed type exists\n            return; // If not, quit method\n        }\n\n        let bag = {type, target};\n\n        const events = this.events[type].slice(); // Little hack to clone array\n\n        for (const event of events) { // Iterate all events\n            if (event && event.callback) { // Check if callback of event is set\n                event.callback.apply(event.scope, [bag, ...args, ...event.args]); // Call callback\n            }\n        }\n    }\n\n    debug() {\n        let str = \"\";\n        for (const [type, events] of Object.entries(this.events)) {\n            for (const event of events) {\n                let className = event.scope && event.scope.constructor.name || \"Anonymous\";\n                str += `${className} listening for \"${type}\"\\n`;\n            }\n        }\n        return str;\n    }\n\n}\n\nexport const global = new EventBus();\n"],"names":["EventBus","[object Object]","this","events","type","callback","scope","args","push","filter","event","numOfCallbacks","length","undefined","some","scopeIsSame","callbackIsSame","target","bag","slice","apply","str","Object","entries","constructor","name","global"],"mappings":"AAAO,MAAMA,EAETC,cACIC,KAAKC,OAAS,GAUlBF,GAAGG,EAAMC,EAAUC,KAAUC,QACQ,IAAtBL,KAAKC,OAAOC,KACnBF,KAAKC,OAAOC,GAAQ,IAExBF,KAAKC,OAAOC,GAAMI,KAAK,CAACF,MAAAA,EAAOD,SAAAA,EAAUE,KAAAA,IAS7CN,IAAIG,EAAMC,EAAUC,GAChB,QAAiC,IAAtBJ,KAAKC,OAAOC,GACnB,OAKJF,KAAKC,OAAOC,GAAQF,KAAKC,OAAOC,GAAMK,OADrBC,GAASA,EAAMJ,QAAUA,GAASI,EAAML,WAAaA,GAU1EJ,IAAIG,EAAMC,EAAUC,GAChB,QAAiC,IAAtBJ,KAAKC,OAAOC,GACnB,OAAO,EAIX,IAAIO,EAAiBT,KAAKC,OAAOC,GAAMQ,OACvC,QAAiBC,IAAbR,QAAoCQ,IAAVP,EAC1B,OAAOK,EAAiB,EAU5B,OAAOT,KAAKC,OAAOC,GAAMU,KAPLJ,IAChB,MAAMK,GAAcT,GAAQI,EAAMJ,QAAUA,EACtCU,EAAiBN,EAAML,WAAaA,EAC1C,GAAIU,GAAeC,EACf,OAAO,IAYnBf,KAAKG,EAAMa,KAAWV,GAClB,QAAiC,IAAtBL,KAAKC,OAAOC,GACnB,OAGJ,IAAIc,EAAM,CAACd,KAAAA,EAAMa,OAAAA,GAEjB,MAAMd,EAASD,KAAKC,OAAOC,GAAMe,QAEjC,IAAK,MAAMT,KAASP,EACZO,GAASA,EAAML,UACfK,EAAML,SAASe,MAAMV,EAAMJ,MAAO,CAACY,KAAQX,KAASG,EAAMH,OAKtEN,QACI,IAAIoB,EAAM,GACV,IAAK,MAAOjB,EAAMD,KAAWmB,OAAOC,QAAQrB,KAAKC,QAC7C,IAAK,MAAMO,KAASP,EAAQ,CAExBkB,MADgBX,EAAMJ,OAASI,EAAMJ,MAAMkB,YAAYC,MAAQ,8BACzBrB,OAG9C,OAAOiB,GAKH,MAACK,EAAS,IAAI1B"}